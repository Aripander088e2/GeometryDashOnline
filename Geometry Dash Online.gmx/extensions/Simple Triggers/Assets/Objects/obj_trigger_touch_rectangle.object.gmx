<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_trigger_touch_rectangle</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>-99999</depth>
  <persistent>0</persistent>
  <parentName>par_trigger</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup
event_inherited();
/*////////////////////////////////////////////////////
 This kind of trigger will run when the target object
 touches it. To be clear, this is not when the 
 instances overlap, but rather when the x- and 
 yposition of the target is inside the rectangle.
 
 The custom flag 'rapid' allows the trigger to keep 
 firing until not touched any more. Set this variable 
 in the creation code after using the trigger_set 
 script.
 
 The trigger will of course still only fire once if
 'run_once' is set to true.
 
 The flag 'overlap' allows the trigger to check bbox
 against mask instead of using the targets x- and
 yposition.
*/

rapid = false;
overlap = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Fire trigger
//I use 'with' in case we need to check against multiple instances
with target {
 if other.activated &amp;&amp; is_real(ds_map_find_value(other.xprev,id)) {
  //Get the bounds of the trigger's rectangle
  var __x1, __y1, __x2, __y2, __x3, __y3, __x4, __y4;
  __x1 = other.x;
  __y1 = other.y;
  __x2 = __x1+lengthdir_x(other.sprite_width,other.image_angle);
  __y2 = __y1+lengthdir_y(other.sprite_width,other.image_angle);
  __x3 = __x1+lengthdir_x(other.sprite_height,other.image_angle-90);
  __y3 = __y1+lengthdir_y(other.sprite_height,other.image_angle-90);
  __x4 = __x2+__x3-__x1;
  __y4 = __y2+__y3-__y1;
  //Test position against two triangles (forming the rectangle)
  if (!other.overlap &amp;&amp; (point_in_triangle(x,y,__x1,__y1,__x2,__y2,__x3,__y3) || point_in_triangle(x,y,__x4,__y4,__x2,__y2,__x3,__y3)) &amp;&amp; 
     (other.rapid || !(point_in_triangle(other.xprev[? id],other.yprev[? id],__x1,__y1,__x2,__y2,__x3,__y3) || point_in_triangle(other.xprev[? id],other.yprev[? id],__x4,__y4,__x2,__y2,__x3,__y3)))) || 
     (other.overlap &amp;&amp; trigger_meeting(x,y) &amp;&amp; (other.rapid || !trigger_meeting(other.xprev[? id],other.yprev[? id]))) {
   /*////////////////////////////////////////////////////
    The script should be run from the trigger itself.
    Also, you can use the keyword 'other' to access the
    instance triggering the trigger (you can for example
    use this in the script).
   */ 
   with other {
    //Stop from running again if set to run only once
    if run_once {
     activated = false;
    }
    //Run
    trigger_run();
   }
  }
  //Return to saved position
  
 } else {
  //No reason looping through any more if not activated
  break;
 }
}
///Update previous positions
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
