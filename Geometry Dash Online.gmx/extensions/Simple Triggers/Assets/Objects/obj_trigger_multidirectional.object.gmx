<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_trigger_multidirectional</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>-99999</depth>
  <persistent>0</persistent>
  <parentName>par_trigger</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup
event_inherited();
/*////////////////////////////////////////////////////
 This kind of trigger will run when the target object
 passes from one side of the trigger to the other, all
 depending on the image angle of the trigger itself.
 
 Unlike the directional trigger, however, this one 
 fires when the target passes from either side!
 
 In short, if the image angle is set to 0, you will 
 need to pass it going from left to right, or right to
 left, and if you set it to 270 you will need to pass
 it from above it to below, or vice versa. 
 
 The custom flag 'radius' will limit the trigger to only 
 firing when the target is within a given range. 
 
 If the value set is 0 or negative, the trigger will
 not have a forced range.
*/

radius = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Fire trigger
//I use 'with' in case we need to check against multiple instances
with target {
 if other.activated &amp;&amp; is_real(ds_map_find_value(other.xprev,id)) {
  //Make positions comparable on one axis by rotating the positions
  var __dir, __dist, __x, __dir_prev, __dist_prev, __x_prev;
  __dir = point_direction(other.x,other.y,x,y)-other.image_angle;
  __dist = point_distance(other.x,other.y,x,y);
  __x = other.x+lengthdir_x(__dist,__dir);
  
  __dir_prev = point_direction(other.x,other.y,other.xprev[? id],other.yprev[? id])-other.image_angle;
  __dist_prev = point_distance(other.x,other.y,other.xprev[? id],other.yprev[? id]);
  __x_prev = other.x+lengthdir_x(__dist_prev,__dir_prev);
  
  //Compare values
  if (other.radius &lt;= 0 || point_distance(x,y,other.x,other.y) &lt;= other.radius) &amp;&amp; sign(__x-other.x) != sign(__x_prev-other.x) {
   /*////////////////////////////////////////////////////
    The script should be run from the trigger itself.
    Also, you can use the keyword 'other' to access the
    instance triggering the trigger (you can for example
    use this in the script).
   */ 
   with other {
    //Stop from running again if set to run only once
    if run_once {
     activated = false;
    }
    //Run
    trigger_run();
   }
  }
 } else {
  //No reason looping through any more if not activated
  break;
 }
}
///Update previous positions
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
