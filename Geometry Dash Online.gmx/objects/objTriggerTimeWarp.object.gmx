<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>par_trigger</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup
event_inherited();
/*////////////////////////////////////////////////////
 This kind of trigger will run when the target object
 passes from one side of the trigger to the other, all
 depending on the image angle of the trigger itself.
 
 Unlike the directional trigger, however, this one 
 fires when the target passes from either side!
 
 In short, if the image angle is set to 0, you will 
 need to pass it going from left to right, or right to
 left, and if you set it to 270 you will need to pass
 it from above it to below, or vice versa. 
 
 The custom flag 'radius' will limit the trigger to only 
 firing when the target is within a given range. 
 
 If the value set is 0 or negative, the trigger will
 not have a forced range.
*/

radius = -1;
rapid = false;
overlap = false;
TriggerMode = 0;
TimeWarpTrigger = 1;

TimeNum01 = 1;
TimeNum02 = 1;

AngleBlocks = 0;
ScaleBlocks = 1;
AlphaBlocks = 1;
sprite_index = sprTriggers;
image_speed = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Fire trigger
//I use 'with' in case we need to check against multiple instances

switch(TriggerMode) {
    case 0:
    with target {
     if other.activated &amp;&amp; is_real(ds_map_find_value(other.xprev,id)) {
      //Make positions comparable on one axis
      var __dir, __dist, __xT, __dir_prev, __dist_prev, __x_prev;
      __dir = point_direction(other.x,other.y,x,y)-other.image_angle;
      __dist = point_distance(other.x,other.y,x,y);
      __xT = other.x+lengthdir_x(__dist,__dir);
      
      __dir_prev = point_direction(other.x,other.y,other.xprev[? id],other.yprev[? id])-other.image_angle;
      __dist_prev = point_distance(other.x,other.y,other.xprev[? id],other.yprev[? id]);
      __x_prev = other.x+lengthdir_x(__dist_prev,__dir_prev);
      
      //Compare values
      if (other.radius &lt;= 0 || point_distance(x,y,other.x,other.y) &lt;= other.radius) &amp;&amp; __xT &gt;= other.x &amp;&amp; (__x_prev &lt; other.x || other.rapid) {
       /*////////////////////////////////////////////////////
        The script should be run from the trigger itself.
        Also, you can use the keyword 'other' to access the
        instance triggering the trigger (you can for example
        use this in the script).
       */ 
       with other {
        //Stop from running again if set to run only once
        if run_once {
         activated = false;
        }
        //Run
        trigger_run();
       }
      }
     } else {
      //No reason looping through any more if not activated
      break;
     }
    }
    break;
    
    case 1:
    with target {
     if other.activated &amp;&amp; is_real(ds_map_find_value(other.xprev,id)) {
      //Get the bounds of the trigger's rectangle
      var __x1, __y1, __x2, __y2, __x3, __y3, __x4, __y4;
        __x1 = other.x;
        __y1 = other.y;
        __x2 = __x1-other.sprite_width/2;
        __y2 = __y1-other.sprite_height/2;
        __x3 = __x1+other.sprite_width/2;
        __y3 = __y1+other.sprite_height/2;
        __x4 = __x2+__x3-__x1;
        __y4 = __y2+__y3-__y1;
      //Test position against two triangles (forming the rectangle)
      if (!other.overlap &amp;&amp; (point_in_rectangle(x,y,__x2,__y2,__x3,__y3) || point_in_rectangle(x,y,__x2,__y2,__x3,__y3))
         != (point_in_rectangle(other.xprev[? id],other.yprev[? id],__x2,__y2,__x3,__y3) || point_in_rectangle(other.xprev[? id],other.yprev[? id],__x2,__y2,__x3,__y3))) || 
         (other.overlap &amp;&amp; trigger_meeting(x,y) != trigger_meeting(other.xprev[? id],other.yprev[? id])) {
       /*////////////////////////////////////////////////////
        The script should be run from the trigger itself.
        Also, you can use the keyword 'other' to access the
        instance triggering the trigger (you can for example
        use this in the script).
       */ 
       with other {
        //Stop from running again if set to run only once
        if run_once {
         activated = false;
        }
        //Run
        trigger_run();
       }
      }
      //Return to saved position
      
     } else {
      //No reason looping through any more if not activated
      break;
     }
    }
    break;
}

trigger_set(oPlayer, scr_triggerTimeWarp, false)

///Update previous positions
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_xscale = 1.17 * ScaleBlocks;
image_yscale = 1.17 * ScaleBlocks;
image_angle = 360 * AngleBlocks;
image_alpha = 1 * AlphaBlocks;

draw_sprite_ext(sprite_index, 0, x, y, image_xscale, image_yscale, image_angle, c_white, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
