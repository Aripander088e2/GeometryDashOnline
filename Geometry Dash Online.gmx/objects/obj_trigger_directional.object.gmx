<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>-99999</depth>
  <persistent>0</persistent>
  <parentName>par_trigger</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup
event_inherited();
/*////////////////////////////////////////////////////
 This kind of trigger will run when the target object
 passes from one side of the trigger to the other, all
 depending on the image angle of the trigger itself.
 
 In short, if the image angle is set to 0, you will 
 need to pass it going from left to right, and if you
 set it to 270 you will need to pass it from above it
 to below.
 
 The custom flag 'rapid' allows the trigger to keep 
 firing while the target is on the firing side of the
 trigger. Set this variable in the creation code after
 using the trigger_set script.
 
 The trigger will of course still only fire once if
 'run_once' is set to true.
 
 The flag 'radius' will limit the trigger to only 
 firing when the target is within a given range. 
 
 If the value set is 0 or negative, the trigger will
 not have a forced range.
*/

rapid = false;
radius = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Fire trigger
//I use 'with' in case we need to check against multiple instances
with target {
 if other.activated &amp;&amp; is_real(ds_map_find_value(other.xprev,id)) {
  //Make positions comparable on one axis
  var __dir, __dist, __xT, __dir_prev, __dist_prev, __x_prev;
  __dir = point_direction(other.x,other.y,x,y)-other.image_angle;
  __dist = point_distance(other.x,other.y,x,y);
  __xT = other.x+lengthdir_x(__dist,__dir);
  
  __dir_prev = point_direction(other.x,other.y,other.xprev[? id],other.yprev[? id])-other.image_angle;
  __dist_prev = point_distance(other.x,other.y,other.xprev[? id],other.yprev[? id]);
  __x_prev = other.x+lengthdir_x(__dist_prev,__dir_prev);
  
  //Compare values
  if (other.radius &lt;= 0 || point_distance(x,y,other.x,other.y) &lt;= other.radius) &amp;&amp; __xT &gt;= other.x &amp;&amp; (__x_prev &lt; other.x || other.rapid) {
   /*////////////////////////////////////////////////////
    The script should be run from the trigger itself.
    Also, you can use the keyword 'other' to access the
    instance triggering the trigger (you can for example
    use this in the script).
   */ 
   with other {
    //Stop from running again if set to run only once
    if run_once {
     activated = false;
    }
    //Run
    trigger_run();
   }
  }
 } else {
  //No reason looping through any more if not activated
  break;
 }
}
///Update previous positions
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
